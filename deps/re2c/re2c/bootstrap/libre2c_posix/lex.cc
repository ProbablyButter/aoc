/* Generated by re2c 1.1.1 on Wed Jan 16 21:53:43 2019 */
#line 1 "../libre2c_posix/lex.re"
#include <stdio.h>

#include <cstdint>

#include "src/encoding/enc.h"
#include "src/parse/ast.h"
#include "src/options/msg.h"
#include "src/util/range.h"
#include "src/util/s_to_n32_unsafe.h"
#include "parse.h"
#include "libre2c_posix/lex.h"


extern YYSTYPE yylval;

namespace re2c {

static int32_t lex_cls_chr(const char *&, uint32_t &);

#line 29 "../libre2c_posix/lex.re"


int lex(const char *&cur)
{
    const char *yyt1;const char *yyt2;
    const char *mar, *x, *y;
    std::vector<ASTRange> cls;
    bool neg = false;
    uint32_t l, u;


#line 35 "libre2c_posix/lex.cc"
{
	char yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};
	yych = *cur;
	if (yych <= '>') {
		if (yych <= '\'') {
			if (yych <= 0x00) goto yy2;
			if (yych == '$') goto yy6;
			goto yy4;
		} else {
			if (yych <= '+') goto yy8;
			if (yych == '.') goto yy10;
			goto yy4;
		}
	} else {
		if (yych <= ']') {
			if (yych <= '?') goto yy8;
			if (yych == '[') goto yy12;
			goto yy4;
		} else {
			if (yych <= 'z') {
				if (yych <= '^') goto yy6;
				goto yy4;
			} else {
				if (yych <= '{') goto yy14;
				if (yych <= '|') goto yy8;
				goto yy4;
			}
		}
	}
yy2:
	++cur;
#line 42 "../libre2c_posix/lex.re"
	{ return 0; }
#line 103 "libre2c_posix/lex.cc"
yy4:
	++cur;
yy5:
#line 77 "../libre2c_posix/lex.re"
	{
        ASTChar c(static_cast<uint32_t>(cur[-1]), 0);
        std::vector<ASTChar> *str = new std::vector<ASTChar>;
        str->push_back(c);
        yylval.regexp = ast_str(0, 0, str, false);
        return REGEXP;
    }
#line 115 "libre2c_posix/lex.cc"
yy6:
	++cur;
#line 46 "../libre2c_posix/lex.re"
	{
        error("anchors are not supported");
        return ERROR;
    }
#line 123 "libre2c_posix/lex.cc"
yy8:
	++cur;
#line 44 "../libre2c_posix/lex.re"
	{ return cur[-1]; }
#line 128 "libre2c_posix/lex.cc"
yy10:
	++cur;
#line 72 "../libre2c_posix/lex.re"
	{
        yylval.regexp = ast_dot(0, 0);
        return REGEXP;
    }
#line 136 "libre2c_posix/lex.cc"
yy12:
	yych = *++cur;
	if (yych == '^') goto yy15;
#line 52 "../libre2c_posix/lex.re"
	{ goto cls; }
#line 142 "libre2c_posix/lex.cc"
yy14:
	yych = *(mar = ++cur);
	if (yych <= '/') goto yy5;
	if (yych <= '9') {
		yyt1 = cur;
		goto yy17;
	}
	goto yy5;
yy15:
	++cur;
#line 51 "../libre2c_posix/lex.re"
	{ neg = true; goto cls; }
#line 155 "libre2c_posix/lex.cc"
yy17:
	yych = *++cur;
	if (yybm[0+yych] & 128) {
		goto yy17;
	}
	if (yych == ',') goto yy20;
	if (yych == '}') goto yy21;
yy19:
	cur = mar;
	goto yy5;
yy20:
	yych = *++cur;
	if (yych <= '/') goto yy19;
	if (yych <= '9') {
		yyt2 = cur;
		goto yy23;
	}
	if (yych == '}') goto yy25;
	goto yy19;
yy21:
	++cur;
	x = yyt1;
#line 54 "../libre2c_posix/lex.re"
	{
        if (!s_to_u32_unsafe(x, cur - 1, yylval.bounds.min)) goto err_cnt;
        yylval.bounds.max = yylval.bounds.min;
        return COUNT;
    }
#line 184 "libre2c_posix/lex.cc"
yy23:
	yych = *++cur;
	if (yych <= '/') goto yy19;
	if (yych <= '9') goto yy23;
	if (yych == '}') goto yy27;
	goto yy19;
yy25:
	++cur;
	x = yyt1;
#line 66 "../libre2c_posix/lex.re"
	{
        if (!s_to_u32_unsafe(x, cur - 2, yylval.bounds.min)) goto err_cnt;
        yylval.bounds.max = AST::MANY;
        return COUNT;
    }
#line 200 "libre2c_posix/lex.cc"
yy27:
	++cur;
	x = yyt1;
	y = yyt2;
#line 60 "../libre2c_posix/lex.re"
	{
        if (!s_to_u32_unsafe(x, y - 1, yylval.bounds.min)
            || !s_to_u32_unsafe(y, cur - 1, yylval.bounds.max)) goto err_cnt;
        return COUNT;
    }
#line 211 "libre2c_posix/lex.cc"
}
#line 84 "../libre2c_posix/lex.re"


cls:
    if (lex_cls_chr(cur, l) != 0) goto err;

#line 219 "libre2c_posix/lex.cc"
{
	char yych;
	yych = *(mar = cur);
	if (yych == '-') goto yy32;
yy31:
#line 89 "../libre2c_posix/lex.re"
	{ u = l; goto add; }
#line 227 "libre2c_posix/lex.cc"
yy32:
	yych = *++cur;
	if (yych != ']') goto yy34;
	cur = mar;
	goto yy31;
yy34:
	++cur;
	cur -= 1;
#line 90 "../libre2c_posix/lex.re"
	{ if (lex_cls_chr(cur, u) != 0) goto err; goto add; }
#line 238 "libre2c_posix/lex.cc"
}
#line 91 "../libre2c_posix/lex.re"

add:
    if (l > u) goto err;
    cls.push_back(ASTRange(l, u, 0));

#line 246 "libre2c_posix/lex.cc"
{
	char yych;
	yych = *cur;
	if (yych == ']') goto yy39;
#line 96 "../libre2c_posix/lex.re"
	{ goto cls; }
#line 253 "libre2c_posix/lex.cc"
yy39:
	++cur;
#line 97 "../libre2c_posix/lex.re"
	{
        std::vector<ASTRange> *p = new std::vector<ASTRange>;
        p->swap(cls);
        yylval.regexp = ast_cls(0, 0, p, neg);
        return REGEXP;
    }
#line 263 "libre2c_posix/lex.cc"
}
#line 103 "../libre2c_posix/lex.re"


err:
    error("syntax error: %s\n", cur);
    return ERROR;

err_cnt:
    error("repetition count overflow");
    return ERROR;
}

int32_t lex_cls_chr(const char *&cur, uint32_t &c)
{

#line 280 "libre2c_posix/lex.cc"
{
	char yych;
	yych = *cur;
	if (yych <= 0x00) goto yy43;
	if (yych == '[') goto yy47;
	goto yy45;
yy43:
	++cur;
#line 117 "../libre2c_posix/lex.re"
	{ return 1; }
#line 291 "libre2c_posix/lex.cc"
yy45:
	++cur;
yy46:
#line 122 "../libre2c_posix/lex.re"
	{ c = static_cast<uint8_t>(cur[-1]); return 0; }
#line 297 "libre2c_posix/lex.cc"
yy47:
	yych = *++cur;
	if (yych <= '9') {
		if (yych != '.') goto yy46;
	} else {
		if (yych <= ':') goto yy50;
		if (yych == '=') goto yy52;
		goto yy46;
	}
	++cur;
#line 118 "../libre2c_posix/lex.re"
	{ error("collating characters not supported"); return 1; }
#line 310 "libre2c_posix/lex.cc"
yy50:
	++cur;
#line 119 "../libre2c_posix/lex.re"
	{ error("character classes not supported"); return 1; }
#line 315 "libre2c_posix/lex.cc"
yy52:
	++cur;
#line 120 "../libre2c_posix/lex.re"
	{ error("equivalence classes not supported"); return 1; }
#line 320 "libre2c_posix/lex.cc"
}
#line 123 "../libre2c_posix/lex.re"

}

} // namespace re2c
